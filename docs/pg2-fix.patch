diff --git a/pg-core/src/java/org/pg/Connection.java b/pg-core/src/java/org/pg/Connection.java
index 1a942bc..ecfb0e5 100644
--- a/pg-core/src/java/org/pg/Connection.java
+++ b/pg-core/src/java/org/pg/Connection.java
@@ -257,6 +257,12 @@ public final class Connection implements AutoCloseable {
                 if (Debug.isON) {
                     Debug.debug(" -> skipping message: %s", msg);
                 }
+            } else if (msg instanceof NoticeResponse nr) {
+                handleNoticeResponse(nr);
+            } else if (msg instanceof ParameterStatus ps) {
+                handleParameterStatus(ps);
+            } else if (msg instanceof NotificationResponse notif) {
+                handleNotificationResponse(notif);
             } else if (msg instanceof ReadyForQuery) {
                 break;
             } else if (msg instanceof ErrorResponse e) {
@@ -732,7 +738,16 @@ public final class Connection implements AutoCloseable {
                            final ExecuteParams executeParams
     ) {
         final List<Object> params = executeParams.params();
-        final int[] OIDs = stmt.parameterDescription().oids();
+        final ParameterDescription pd = stmt.parameterDescription();
+        if (pd == null) {
+            throw new PGError(
+                "ParameterDescription is null for statement '%s' (SQL: %s). " +
+                "This indicates a protocol desync â€” the connection may be corrupted.",
+                stmt.parse().statement(),
+                stmt.parse().sql()
+            );
+        }
+        final int[] OIDs = pd.oids();
         final int size = params.size();
 
         if (size != OIDs.length) {
@@ -1275,10 +1290,7 @@ public final class Connection implements AutoCloseable {
         config.executor().execute(() -> f.invoke(arg));
     }
 
-    private void handleNotificationResponse (final NotificationResponse msg, final Result res) {
-        res.incNotificationCount();
-        // Sometimes, it's important to know whether a notification
-        // was triggered by the current connection or another.
+    private void handleNotificationResponse (final NotificationResponse msg) {
         final boolean isSelf = msg.pid() == pid;
         final Object obj = msg.toClojure().assoc(KW.self_QMARK, isSelf);
         final IFn handler = config.fnNotification();
@@ -1289,6 +1301,11 @@ public final class Connection implements AutoCloseable {
         }
     }
 
+    private void handleNotificationResponse (final NotificationResponse msg, final Result res) {
+        res.incNotificationCount();
+        handleNotificationResponse(msg);
+    }
+
     private void handleNoticeResponse (final NoticeResponse msg) {
         final IFn handler = config.fnNotice();
         final Object obj = msg.toClojure();
@@ -1512,6 +1529,19 @@ public final class Connection implements AutoCloseable {
         }
     }
 
+    /**
+     * Check if the connection's input stream has unread data.
+     * Unread data after a complete operation indicates protocol desync.
+     * Used by Pool to detect corrupted connections before returning them.
+     */
+    public boolean hasUnreadData () {
+        try {
+            return inStream != null && inStream.available() > 0;
+        } catch (IOException e) {
+            return true;
+        }
+    }
+
     @SuppressWarnings("unused")
     public boolean isTxError () {
         try (final TryLock ignored = lock.get()) {
diff --git a/pg-core/src/java/org/pg/Pool.java b/pg-core/src/java/org/pg/Pool.java
index 322662f..7f03551 100644
--- a/pg-core/src/java/org/pg/Pool.java
+++ b/pg-core/src/java/org/pg/Pool.java
@@ -259,6 +259,19 @@ public final class Pool implements AutoCloseable {
             return;
         }
 
+        // Check for protocol desync: unread data means the connection is corrupted.
+        // Discard it rather than poisoning the next borrower.
+        if (conn.hasUnreadData()) {
+            logger.log(System.Logger.Level.WARNING,
+                "Connection {0} has unread data in input stream, closing (pool {1})",
+                conn.getId(), id);
+            closeConnection(conn);
+            try (TryLock ignored = lock.get()) {
+                removeUsed(conn);
+            }
+            return;
+        }
+
         // else
         try (TryLock ignored = lock.get()) {
             removeUsed(conn);
diff --git a/pg-core/src/java/org/pg/processor/Processors.java b/pg-core/src/java/org/pg/processor/Processors.java
index 5b1826e..2427178 100644
--- a/pg-core/src/java/org/pg/processor/Processors.java
+++ b/pg-core/src/java/org/pg/processor/Processors.java
@@ -93,6 +93,7 @@ public class Processors {
         oidMap.set(OID.BYTEA, new Bytea());
         oidMap.set(OID.BOOL, new Bool());
         oidMap.set(OID.BIT, new Bit());
+        oidMap.set(OID.VOID, new Void());
         // date & time
         oidMap.set(OID.TIMESTAMPTZ, new Timestamptz());
         oidMap.set(OID.TIMESTAMP, new Timestamp());
diff --git a/pg-core/src/java/org/pg/processor/Void.java b/pg-core/src/java/org/pg/processor/Void.java
new file mode 100644
index 0000000..f428ef1
--- /dev/null
+++ b/pg-core/src/java/org/pg/processor/Void.java
@@ -0,0 +1,32 @@
+package org.pg.processor;
+
+import org.pg.codec.CodecParams;
+import java.nio.ByteBuffer;
+
+/**
+ * Processor for the VOID type (OID 2278).
+ * PostgreSQL returns VOID for functions with no meaningful return value
+ * (e.g., pg_notify). The value is always empty/null.
+ */
+public class Void extends AProcessor {
+
+    @Override
+    public Object decodeBin(final ByteBuffer bb, final CodecParams codecParams) {
+        return null;
+    }
+
+    @Override
+    public Object decodeTxt(final String text, final CodecParams codecParams) {
+        return null;
+    }
+
+    @Override
+    public ByteBuffer encodeBin(final Object x, final CodecParams codecParams) {
+        return ByteBuffer.allocate(0);
+    }
+
+    @Override
+    public String encodeTxt(final Object x, final CodecParams codecParams) {
+        return "";
+    }
+}
